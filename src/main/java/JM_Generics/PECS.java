package JM_Generics;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Класс Dog является наследником класса Pet
 * Класс SpecialDog - наследником Dog
 * */

public class PECS {
    public static void main(String[] args) {

        /*
        Попытаюсь объяснить дженерики в коллекциях, демонстрируя доступность родных
        и унаследованных методов у разных объектов в коллекциях при разных
        обстоятельствах.

        Наследование следующее: Object -> Pet -> Dog -> SpecialDog.
                                                  |---> HandyDog
        У класса Pet есть метод:
            void eat() { System.out.println("Pet is eating..."); } - собственный
        У класса Dog есть методы:
            void bark() { System.out.println("Dog is barking..."); } - собственный
            void eat() { System.out.println("Pet is eating..."); } - от предка Pet
        У класса SpecialDog есть методы:
            void search() { System.out.println("SpecialDog is searching..."); } - собственный
            void bark() { System.out.println("Dog is barking..."); } - от предка Dog
            void eat() { System.out.println("Pet is eating..."); } - от предка Pet
        У класса HandyDog есть методы:
            void playTheFool() { System.out.println("HandyDog is playing the fool..."); } -
             - собственный
            void bark() { System.out.println("Dog is barking..."); } - от предка Dog
            void eat() { System.out.println("Pet is eating..."); } - от предка Pet
         */

        /*-----------------------------------------------------------------------------------*/

        List<Object> objects = new ArrayList<>();
        /*
        Здесь <Object> говорит о том, что в этой коллекции могут находиться экземпляры классов
        по иерархии не выше класса Object. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой коллекции
        в ходе перебора коллекции и при получении элементов из коллекции без дополнительных
        манипуляций мы гарантированно можем вызывать методы класса Object (их там несколько)
        и могли бы вызывать методы всех его предков, но у класса Object нет предков.
        Методы потомков Object вызывать не можем.
         */

        List<Pet> pets = new ArrayList<>();
        /*
        Здесь <Pet> говорит о том, что в этой коллекции могут находиться экземпляры классов
        по иерархии не выше класса Pet. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой коллекции
        в ходе перебора коллекции и при получении элементов из коллекции без дополнительных
        манипуляций мы гарантированно можем вызывать метод класса Pet ( eat() ) и
        методы всех его предков - то есть методы класса Object.
        Методы потомков Pet вызывать не можем.
         */

        List<Dog> dogs = new ArrayList<>();
        /*
        Здесь <Dog> говорит о том, что в этой коллекции могут находиться экземпляры классов
        по иерархии не выше класса Dog. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой коллекции
        в ходе перебора коллекции и при получении элементов из коллекции без дополнительных
        манипуляций мы гарантированно можем вызывать метод класса Dog ( bark() ) и методы
        всех его предков - то есть методы классов Object и Pet ( eat() ).
        Методы потомков Dog вызывать не можем.
         */

        List<SpecialDog> specialDogs = new ArrayList<>();
        /*
        Здесь <SpecialDog> говорит о том, что в этой коллекции могут находиться экземпляры
        классов по иерархии не выше класса SpecialDog. Кроме того, У КАЖДОГО ЭЛЕМЕНТА
        этой коллекциив ходе перебора коллекции и при получении элементов из коллекции без
        дополнительных манипуляций мы гарантированно можем вызывать метод класса SpecialDog
        ( search() ) и методы всех его предков - то есть методы классов Object, Pet ( eat() )
        и Dog ( bark() ). Методы потомков SpecialDog вызывать не можем.
         */

        List<HandyDog> handyDogs = new ArrayList<>();
        /*
        Здесь <HandyDog> говорит о том, что в этой коллекции могут находиться экземпляры
        классов по иерархии не выше класса HandyDog. Кроме того, У КАЖДОГО ЭЛЕМЕНТА
        этой коллекциив ходе перебора коллекции и при получении элементов из коллекции без
        дополнительных манипуляций мы гарантированно можем вызывать метод класса HandyDog
        ( playTheFool() ) и методы всех его предков - то есть методы классов Object,
        Pet ( eat() ) и Dog ( bark() ). Методы потомков HandyDog вызывать не можем.
         */



        /*
        Получается, что параметр(аргумент), указанный в треугольных скобках <>, диктует нам
        следующие условия:
        1. Допустимые классы в коллекциях ограничивает сверху.
        2. Допустимые методы в коллекциях ограничивает снизу.

        Например List<Dog> dogs = new ArrayList<>():
        Максимальный допустимый класс - Dog, это и есть верхнее ограничение на класс.
        Положить в коллекцию объект класса, находящегося по иерархии выше чем Dog, например
        Pet, нельзя, но объект самого класса Dog и объекты классов ниже по иерархии можно.
        С методами - наоборот. Параметр разрешает применять к каждому объекту коллекции
        методы класса Dog и классов, находящихся выше по иерархии. И запрещает использовать
        методы классов, находящихся ниже по иерархии, чем класс Dog.

        Подытожим.
        У нашей коллекции List<Dog> dogs = new ArrayList<>() параметр(аргумент) <Dog>
        накладывает следующие ограничения:
        Экземпляры каких классов можно положить: Dog и ниже (new Dog(); new SpecialDog(),
        new HandyDog()).
        Методы каких классов можно использовать: Dog и выше (Dog; Pet; Object).

        Здесь заметно, что только объекты класса Dog могут быть "полноценно" представлены
        в этой коллекции, ведь они сами могут тут находиться и их методы тут присутствуют.
        Если сюда захочет попасть кто-то ниже по иерархии (SpecialDog или HandyDog), но с
        более богатым набором методов - то ему "обрежут" его личные методы и пропустят,
        сказав: "Будь как все! Тут у всех набор методов одинаков: методы классов Object, Pet
        и Dog. И все пользуются только ими." Если кто-то выше по иерархии захочет попасть -
        то его вообще не пустят. Короче говоря, жесткий фейс-контроль.
         */


        /*-----------------------------------------------------------------------------------*/

        // Проверим это на примере коллекции List<Object> objects = new ArrayList<>():

        objects.add(0, new Object());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 0 (по сути в первую
        ячейку) новый объект типа Object. Ведь это его "родная" коллекция, самая подходящая
        для него.
         */
        objects.add(1, new Pet());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 1 (по сути во вторую
        ячейку) новый объект типа Pet. Почему без проблем? Потому что JAVA точно знает,
        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр Pet),
        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена,
        что у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
        При этом, она сразу как бы "закрывает доступ" к единственному собственному методу
        экземпляра Pet - eat(), делая его "невидимым". Теперь этот экземпляр Pet как будто
        обычный экземпляр класса Object (якобы урезанная версия).
         */
        objects.add(2, new Dog());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 2 (по сути в третью
        ячейку) новый объект типа Dog. Почему без проблем? Потому что JAVA точно знает,
        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр Dog),
        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена, что
        у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
        При этом, она сразу как бы "закрывает доступ" ко всем остальным методам экземпляра
        Dog ( собственному методу bark() и унаследованному от Pet методу eat() ), делая их
        "невидимыми". Теперь этот экземпляр Dog как будто обычный экземпляр класса Object
        (якобы урезанная версия).
         */
        objects.add(3, new SpecialDog());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 3 (по сути в четвертую
        ячейку) новый объект типа SpecialDog. Почему без проблем? Потому что JAVA точно знает,
        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр SpecialDog),
        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена, что
        у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
        При этом, она сразу как бы "закрывает доступ" ко всем остальным методам экземпляра
        SpecialDog ( собственному методу search(), унаследованному от Dog методу bark() и
        унаследованному от Pet методу eat() ), делая их "невидимыми". Теперь этот экземпляр
        SpecialDog как будто обычный экземпляр класса Object (якобы урезанная версия).
         */
        objects.add(4, new HandyDog());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 4 (по сути в пятую
        ячейку) новый объект типа HandyDog. Почему без проблем? Потому что JAVA точно знает,
        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр HandyDog),
        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена, что
        у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
        При этом, она сразу как бы "закрывает доступ" ко всем остальным методам экземпляра
        HandyDog ( собственному методу playTheFool(), унаследованному от Dog методу bark() и
        унаследованному от Pet методу eat() ), делая их "невидимыми". Теперь этот экземпляр
        HandyDog как будто обычный экземпляр класса Object (якобы урезанная версия).
         */


        /*
        Мы помним ограничения этой конкретной коллекции: у этих объектов в коллекции мы
        можем вызвать только методы класса Object, их личные методы и унаследованные методы
        у классов, находящихся вплоть до Object, мы вызвать НЕ МОЖЕМ:
         */
        // 1.Перебираем коллекцию, в ходе чего у каждого элемента вызываем метод класса Object:
        for (Object o : objects) {
            System.out.println(o.hashCode());
        } // Без проблем итерируем и вызываем метод класса
        // Object у каждого элемента коллекции. У меня в консоль вывелось следующее:
        // 1639705018
        // 1627674070
        // 1360875712
        // 1625635731

        // 2.Теперь получим элементы из коллекции методом get():

        Object object0 = objects.get(0); // достали первый объект (который имел тип Object)
        // и записали в переменную object0. Вызываем у объекта любой метод класса Object,
        // например toString():
        System.out.println(object0.toString()); // без проблем вызываются методы класса Object

        Object object1 = objects.get(1);// достали первый объект (который имел тип Pet)
        // и записали в переменную object1. Вызываем у объекта любой метод класса Object,
        // например hashCode():
        System.out.println(object1.hashCode()); // без проблем вызываются методы класса Object.

        // Это же был у нас объект типа Pet? Попытаемся достать этот объект и записать его в
        // переменную типа Pet:
//        Pet pet1 = objects.get(1); // компилятор ругается^ потому что мы пытаемся в переменную
        // типа Pet записать объект типа Object, поэтому надо явно указать, что мы уверены, что
        // это объект типа Pet и сделать приведение типов (cast):
        Pet pet0 = (Pet) objects.get(1); // Всё отлично. Мы как бы "распаковали" из объекта
        // класса Object наш объект класса Pet. И теперь можем вызывать у него не только методы
        // класса Object, но и методы класса Pet:
        System.out.println(pet0.hashCode()); // Ок!
        pet0.eat(); // "Pet is eating..." Всё отлично. Его собственный метод вызывается без проблем.


        // Аналогичная ситуация с объектами типа Dog и SpecialDog:
        Object object2 = objects.get(2); // Можем достать объект типа Dog "нераспакованным" и
        // иметь возможность вызывать только методы класса Object. Либо:
        Dog dog0 = (Dog) objects.get(2); // Можем достать объект типа Dog "распакованным" и
        // иметь возможность вызывать у него не только методы класса Object, но и собственный
        // метод класса Dog - bark(), и унаследованный от Pet метод eat():
        System.out.println(dog0.hashCode()); // Ок!
        dog0.eat(); // "Pet is eating..."
        dog0.bark(); // "Dog is barking..."

        Object object3 = objects.get(3); // Можем достать объект типа SpecialDog
        // "нераспакованным" и иметь возможность вызывать только методы класса Object. Либо:
        SpecialDog specialDog0 = (SpecialDog) objects.get(3); // Можем достать объект типа
        // SpecialDog "распакованным" и иметь возможность вызывать у него не только методы
        // класса Object, но и собственный метод класса SpecialDog - search(), унаследованный
        // от Dog метод bark(), и унаследованный от Pet метод eat():
        System.out.println(specialDog0.hashCode()); // Ок!
        specialDog0.eat(); // "Pet is eating..."
        specialDog0.bark(); // "Dog is barking..."
        specialDog0.search(); // "SpecialDog is searching..."

        Object object4 = objects.get(4); // Можем достать объект типа HandyDog
        // "нераспакованным" и иметь возможность вызывать только методы класса Object. Либо:
        HandyDog handyDog0 = (HandyDog) objects.get(4); // Можем достать объект типа HandyDog
        // "распакованным" и иметь возможность вызывать у него не только методы класса Object,
        // но и собственный метод класса HandyDog - playTheFool(), унаследованный от Dog метод
        // bark(), и унаследованный от Pet метод eat():
        System.out.println(handyDog0.hashCode()); // Ок!
        handyDog0.eat(); // "Pet is eating..."
        handyDog0.bark(); // "Dog is barking..."
        handyDog0.playTheFool(); // "HandyDog is playing the fool..."

//        List<Pet> lp = new ArrayList<Dog>();

        /*-----------------------------------------------------------------------------------*/

        // Проверим это на примере коллекции List<Pet> pets = new ArrayList<>():

//        pets.add(0, new Object());
        /*
        Добавить в эту коллекцию объект типа Object не получится - помним про ограничение
        классов сверху, а методов снизу.
         */
        pets.add(0, new Pet());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 0 (по сути в первую
        ячейку) новый объект типа Pet. Ведь это его "родная" коллекция, самая подходящая
        для него.
         */
        pets.add(1, new Dog());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 1 (по сути в вторую
        ячейку) новый объект типа Dog. Почему без проблем? Потому что JAVA точно знает,
        что принимая в эту коллекцию (List<Pet>) потомка класса Pet (экземпляр Dog),
        она его преобразует в объект класса Pet, как бы "запаковывает" его, и уверена, что
        у него точно есть методы класса Pet и класса Object, и она сможет их вызвать у этого
        объекта. При этом, она сразу как бы "закрывает доступ" ко всем остальным методам
        экземпляра Dog ( собственному методу bark() ), делая его "невидимым". Теперь этот
        экземпляр Dog как будто обычный экземпляр класса Pet (якобы урезанная версия).
         */
        pets.add(2, new SpecialDog());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 2 (по сути в третью ячейку)
        новый объект типа SpecialDog. Почему без проблем? Потому что JAVA точно знает, что
        принимая в эту коллекцию (List<Pet>) потомка класса Pet (экземпляр SpecialDog),
        она его преобразует в объект класса Pet, как бы "запаковывает" его, и уверена, что
        у него точно есть методы класса Pet и класса Object, и она сможет их вызвать у этого
        объекта. При этом, она сразу как бы "закрывает доступ" ко всем остальным методам
        экземпляра SpecialDog ( собственному методу search() ), делая его "невидимым". Теперь
        этот экземпляр SpecialDog как будто обычный экземпляр класса Pet (якобы урезанная
        версия).
         */
        pets.add(3, new HandyDog());
        /*
        Без проблем добавили в коллекцию в ячейку с индексом 3 (по сути в четвертую
        ячейку) новый объект типа HandyDog. Почему без проблем? Потому что JAVA точно знает,
        что принимая в эту коллекцию (List<Pet>) потомка класса Pet (экземпляр HandyDog),
        она его преобразует в объект класса Pet, как бы "запаковывает" его, и уверена, что
        у него точно есть методы класса Pet и класса Object, и она сможет их вызвать у
        этого объекта. При этом, она сразу как бы "закрывает доступ" ко всем остальным
        методам экземпляра HandyDog ( собственному методу playThe Fool() и унаследованному
        от Dog методу bark() ), делая их "невидимыми". Теперь этот экземпляр
        HandyDog как будто обычный экземпляр класса Pet (якобы урезанная версия).
         */


        /*
        Мы помним ограничения этой конкретной коллекции: у этих объектов в коллекции мы
        можем вызвать только методы класса Pet и класса Object, их личные методы и
        унаследованные методы у классов, находящихся вплоть до Pet, мы вызвать НЕ МОЖЕМ:
         */
        // 1.Перебираем коллекцию, в ходе чего у каждого элемента вызываем метод класса Object:
        for (Pet elem : pets) {
            System.out.println(elem.hashCode());
            // Без проблем итерируем и вызываем метод класса
            // Object у каждого элемента коллекции. У меня в консоль вывелось следующее:
            // 1639705018
            // 1627674070
            // 1360875712
            // 1625635731
            elem.eat();
            // Без проблем итерируем и вызываем метод класса
            // Pet у каждого элемента коллекции.
        }



        // 2.Теперь получим элементы из коллекции методом get():

        Pet pet1 = pets.get(0); // достали первый объект (который имел тип Pet)
        // и записали в переменную pet0. Вызываем у объекта любой метод класса Object,
        // например toString():
        System.out.println(pet1.toString()); // без проблем вызываются методы класса Object
        pet1.eat(); // без проблем вызываются методы класса Pet

        // Это же был у нас объект типа Dog? Попытаемся достать этот объект и записать его в
        // переменную типа Dog:
        Dog dog1 = (Dog) pets.get(1);// достали первый объект (который имел тип Dog)
        // и записали в переменную dog1. Вызываем у объекта любые методы классов Object, Pet,
        // Dog:
        System.out.println(dog1.hashCode()); // без проблем вызываются методы класса Object.
        dog1.eat(); // "Pet is eating..."
        dog1.bark(); // "Dog is barking..."

        SpecialDog specialDog1 = (SpecialDog) pets.get(2); // Можем достать объект типа SpecialDog
        // "распакованным" и иметь возможность вызывать у него не только методы класса Object,
        // но и собственный метод класса SpecialDog - search(), унаследованный от Dog метод
        // bark(), и унаследованный от Pet метод eat():
        System.out.println(specialDog1.hashCode()); // Ок!
        specialDog1.eat(); // "Pet is eating..."
        specialDog1.bark(); // "Dog is barking..."
        specialDog1.search(); // "SpecialDog is searching..."

        HandyDog handyDog1 = (HandyDog) pets.get(3); // Можем достать объект типа HandyDog
        // "распакованным" и иметь возможность вызывать у него не только методы класса Object,
        // но и собственный метод класса HandyDog - playTheFool(), унаследованный от Dog метод
        // bark(), и унаследованный от Pet метод eat():
        System.out.println(handyDog1.hashCode()); // Ок!
        handyDog1.eat(); // "Pet is eating..."
        handyDog1.bark(); // "Dog is barking..."
        handyDog1.playTheFool(); // "HandyDog is playing the fool..."

        /*-----------------------------------------------------------------------------------*/
//
//        List<? extends Number> list = new ArrayList<>();
////        list.add(Double.valueOf(1));
////        list.add(Integer.valueOf(1));
//
//
//
////        test1(objects); // не работает, потому что метод test1 принимает
//        // в качестве параметра только коллекции Dog`ов и коллекции потомков Dog,
//        // а List<Object> objects - коллекция объектов предка
//
////        test1(pets);// не работает, потому что метод test1 принимает
//        // в качестве параметра только коллекции Dog`ов и коллекции потомков Dog,
//        // а List<Pet> pets - коллекция объектов предка
//
//        test1(dogs); // ОК!
//        test1(specialDogs); // ОК!
//        test1(handyDogs); // ОК!
//
//
//        test2(objects); // работает, потому что метод test2 принимает
//        // в качестве параметра только коллекции Dog`ов и коллекции предков Dog
//        test2(pets); // работает, потому что метод test2 принимает
//        // в качестве параметра только коллекции Dog`ов и коллекции предков Dog
//        test2(dogs); // работает, потому что метод test2 принимает
//        // в качестве параметра только коллекции Dog`ов и коллекции предков Dog
//
////        test2(specialDogs); // не работает, потому что метод test2 принимает
//        // в качестве параметра только коллекции Dog`ов и коллекции предков Dog,
//        // а List<SpecialDog> specialDogs - коллекция объектов потомка Dog
//
//        /*-----------------------------------------------------------------------------------*/
//
//        List<Pet> petList = new ArrayList<>();
//        System.out.println();
//        copy(pets, petList);
//        System.out.println();
    }

    static void copy (List<? extends Pet> l1, List<? super Pet> l2) {
        System.out.println("Copying from l1 to l2: " + l2.addAll(l1));
    }

    /*
    Представим, что мы хотим провести выставку собак. Надо всё распланировать. Утвердить
    регламент. Пишем правила и регламент выставки:

    Правило №1:
    Решаем, что на нашу выставку смогут прийти разные группы (коллекции) собак: коллекции
    обычных собак - Dog, коллекции специальных собак - SpecialDog и коллекции ручных собак -
    HandyDog. То есть любые коллекции собак от Dog и ниже.
    Реализация правила №1: Наша выставка - это коллекция List<? extends Dog> list.
    Наш метод dogExhibitionRegulation() - это наш регламент выставки с подробным описанием
    происходящего.

    Исходя из Правила №1, мы открываем наши двери для разных коллекции собак, а это значит, что
    на этом этапе, когда мы только разрабатываем концепцию выставки, мы еще не знаем, какие
    конкретно коллекции собак к нам придут. Может придут только List<Dog>, может List<SpecialDog>,
    может List<HandyDog> - нам сейчас неизвестно. Но регламент ( тело метода dogExhibition() )
    нужно написать уже сейчас!!! Соответственно в регламенте нужно подробно указать, кто, как
    и что будет делать. Так как коллекции собак могут быть разные, то мы должны запланировать
    максимально общие действия со всеми коллекциями собак и с каждой собакой в отдельности.
    Поэтому нельзя в регламенте написать, чтобы все собаки, например, валяли дурака ( метод
    playTheFool() у HandyDog), а вдруг к нам придет группа специальных поисковых собак -
    - SpecialDog, а они этого делать не умеют ( у них нет метода playTheFool() ).
    Поэтому вот второе правило:

    Правило №2:
    В ходе выставки обходиться с собаками только как с собаками типа Dog.
    В этом случае мы можем вызывать у них только методы классов Dog, Pet, Object.

    Продолжая думать о будущей выставке, мы задумываемся о том, чтобы на выставку не прорвались
    посторонние собаки! И правда, мы же не знаем, кто к нам будет приходить на выставку, вдруг
    только ручные собаки? Тогда если к нам на выставку прорвется какая-нибудь обычная собака
    Dog ( дворняга)) ), то она смешается с ручными собаками и может подраться с ними, они
    же ручные и безобидные! Этого нельзя допустить. И в этом нам помогает компилятор JAVA - он
    за нас ставит забор вокруг места проведения выставки, который не позволит ни обычным
    собакам Dog, ни специальным поисковым собакам SpecialDog попасть на выставку. Также
    компилятор JAVA запрещает нам самим в нашем же регламенте ( теле метода dogExhibition() )
    ДОБАВЛЯТЬ каких-либо собак ( использовать метод add() ). Говоря тем самым: "Даже не
    мечтайте в ходе будущих выставок приводить других собак, потому что вы сейчас точно не
    можете написать конкретный тип собак из трх возможных, который можно будет добавить на
    выставку (ведь мы же не знаем, какой List<???> собак будет в будущем передан в наш метод).
    Но при этом компилятор JAVA разрешает нам прописать в регламенте, что в ходе будущей
    выстаки собак мы можем ВЗЯТЬ любую собаку и увести ее с выставки. Это не навредит другим
    собакам на выставке и не смешает их с другими типами собак. Отсюда следует третье правило:

    Правило №3:
    Нельзя добавлять собак на выставку, чтобы не смешать, в целях безопасности, а брать и
    уводить с выставки можно, хоть всех.

    Принято считать, что аргумент List<? extends Dog> list это producer - то есть
    производитель или генератор. Это из-за Правила №3 - эта коллекция собак может нам выдавать
    с выставки (генерировать) сколько угодно собак, хоть все. То есть он нам разрешает их
    брать, но получать от нас собак отказывается в целях безопасности.
     */
    public static void dogExhibitionRegulation(List<? extends Dog> list) {
        for(Dog elem : list) {
            elem.eat();
            elem.bark();
//            Правило №2:
//            elem.search(); // В ходе выставки обходиться с собаками только как с собаками
            // типа Dog, а мы пытаемся заставить ее искать что-то ( метод класса SpecialDog )
        }
//        Правило №3:
//        list.add(new Dog()); // никакой тип собак мы добавить не можем , мы же не можем
//        list.add(new SpecialDog()); // предсказывать будущее и быть уверенными, что на
//        list.add(new HandyDog()); // выствку придет какой-то конкретный тип собак, вот и
//        // компилятор JAVA в этом тоже не уверен, поэтому запрещает нам сделать это.
//
//        list.add(new Pet()); // тем более не можем позволить добавить на выставку непонятных
//        list.add(new Object()); // питомцев или какие-то объекты.

        new Object().hashCode();
        new Pet().eat();
        new Dog().bark();
        new SpecialDog().search();
        new HandyDog().playTheFool();
    }



    /*
    Представим, что мы любим собак, хотим подбирать их на улицах и отвозить в приют.
    Надо всё распланировать. Утвердить регламент для сборщиков собак. Пишем правила и
    регламент.

    Наш метод dogHandover() - процесс транспортировки и передачи собак приюту.

    Правило №1:
    Решаем для себя, что будем привозить разных собак: обычных собак - Dog, группы специальных
    собак - SpecialDog и группы ручных собак - HandyDog. То есть любые группы собак от Dog
    и ниже. Значит нам нужны приюты, которые принимают Dog и выше. Ведь нам не подойдут приюты,
    которые принимают, например, SpecialDog и выше (List<? super SpecialDog> list), потому что
    в таком случае этот приют сможет принять от нас SpecialDog и Dog, но не сможет принять от
    нас HandyDog, что нам совершенно не подходит.


    Наш приют - это коллекция List<? super Dog> list. Причем запись
    <? super Dog> означает, что:

    Правило №1:
    Мы обязуемся привозить в приют только Dog и наследников - SpecialDog, HandyDog. И
    приют не примет у нас никого выше Dog. Метод add() работает с Dog, SpecialDog, HandyDog.


    В приюте нет сотрудников, мы просто привозим собак и выпускаем их на территорию
    приюта, а это значит, что нам никто не скажет, какие еще звери/питомцы/и еще непонятно кто
    живет в этом приюте. Но мы можем забрать кого-то из приюта - непонятно кого - какой-то объект
    Object. А идентифицировать его (сделать приведение типов) нам придется самим, но мы должны
    быть в этом уверены, иначе будет исключение. Короче говоря, получать кого-то  из таких
    приютов - дело неблагодарное. Лучше туда отдавать животных. Поэтому правило №2:



    Правило №3:
    Метод get() работает, но с уверенностью он нам может вернуть только непонятный объект Object.
    Приведение типов на нашей совести, но лучше этого не делать.

     */
    public static void dogHandover(List<? super Dog> list) { // List<Dog> list
                                                             // List<Pet> list Dog + Cat + Parrot
                                                             // List<Object> list Dog + Cat + Parrot + Bear + People
        list.add(new SpecialDog());
        list.add(new HandyDog());
        list.add(new Dog());
//        list.get(0);

//        list.add(new Pet()); // Error
//        list.add(new Object()); // Error

//        Object object = list.get(0);
//
//        SpecialDog specialDog = (SpecialDog) list.get(1);
//        HandyDog handyDog = (HandyDog) list.get(0);
//        Dog dog = (Dog) list.get(4);
//        specialDog.eat();
//        specialDog.bark();
//        specialDog.search();
    }

    private static void test1(List<? extends Dog> test) {
//        test.add(new Object()); // Error
//        test.add(new Dog()); // Error
//        test.add(new SpecialDog()); // Error

//        Dog dog = test.get(0);
    }

    private static void test2(List<? super Dog> test) {


        test.add(new Dog());
        test.add(new SpecialDog());
        test.add(new HandyDog());
//        test.add(new Object()); // Error
//        test.add(new Pet()); // Error

        Object d = test.get(0);
        d.hashCode();
    }

//    private static void test1(List<? extends Dog> test) {
//        /*
//        метод test1 принимает в качестве параметра только коллекции
//        Dog`ов и коллекции наследников Dog
//
//        при конструкции <? extends Dog> - можно только перебирать,
//        но не изменять коллекцию, поэтому работает только get
//         */
//        test.add(new Object());
//        test.add(new Pet());
//        test.add(new Dog());
//        test.add(new SpecialDog());
//
//        Dog dog = test.get(0);
//        SpecialDog sdog = test.get(0);
//    }
//
//    private static void test2(List<? super Dog> test) {
//        /*
//        при конструкции <? super Dog> - можно добавлять, но нельзя
//        брать - Object d = test.get(0); // работает, видимо, потому что
//        к Object все приводится:
//         */
//        Object d = test.get(0);
//
//        test.add(new Dog()); //Dog можно положить в Dog
//
//        test.add(new SpecialDog()); // SpecialDog можно положить в Dog,
//        // при get нужно будет приведение типов
//
//        test.add(new Object()); //?? Вышестоящие объекты нельзя
//        // добавлять в коллекцию нижестоящих??
//
//        test.add(new Pet()); //?? Вышестоящие объекты нельзя
//        // добавлять в коллекцию нижестоящих??
//    }
}
class Pet { void eat() { System.out.println("Pet is eating..."); } }
class Dog extends Pet { void bark() { System.out.println("Dog is barking..."); } }
class SpecialDog extends Dog {void search() { System.out.println("SpecialDog is searching..."); } }
class HandyDog extends Dog { void playTheFool() { System.out.println("HandyDog is playing the fool..."); } }
//public class JM_PECS_1 {
//    public static void main(String[] args) {
//
//        /*
//        Попытаюсь объяснить принцип PECS, демонстрируя доступность родных
//        и унаследованных методов у разных объектов в Generic-коллекциях при разных
//        обстоятельствах.
//
//        Наследование следующее: Object -> Pet -> Dog -> SpecialDog.
//        У класса Pet есть метод:
//            void eat() { System.out.println("Pet is eating..."); } - собственный
//        У класса Dog есть методы:
//            void bark() { System.out.println("Dog is barking..."); } - собственный
//            void eat() { System.out.println("Pet is eating..."); } - от предка Pet
//        У класса SpecialDog есть методы:
//            void search() { System.out.println("SpecialDog is searching..."); } - собственный
//            void bark() { System.out.println("Dog is barking..."); } - от предка Dog
//            void eat() { System.out.println("Pet is eating..."); } - от предка Pet
//         */
//
//        /*-----------------------------------------------------------------------------------*/
//
//        List<Object> objects = new ArrayList<>();
//        /*
//        Здесь <Object> говорит о том, что в этой коллекции могут находиться элементы по своей
//        иерархии не выше класса Object. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой коллекции в ходе
//        перебора коллекции и при получении элементов из коллекции без дополнительных
//        манипуляций мы гарантированно можем вызывать методы класса Object (их там несколько)
//        и могли бы вызывать методы всех его предков, но у класса Object нет предков.
//        Методы потомков Object вызывать не можем.
//         */
//
//        List<Pet> pets = new ArrayList<>();
//        /*
//        Здесь <Pet> говорит о том, что в этой коллекции могут находиться элементы по своей
//        иерархии не выше класса Pet. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой коллекции в ходе
//        перебора коллекции и при получении элементов из коллекции без дополнительных
//        манипуляций мы гарантированно можем вызывать методы класса Pet ( eat() ) и
//        методы всех его предков - то есть методы класса Object.
//        Методы потомков Pet вызывать не можем.
//         */
//
//        List<Dog> dogs = new ArrayList<>();
//        /*
//        Здесь <Dog> говорит о том, что в этой коллекции могут находиться элементы по своей
//        иерархии не выше класса Dog. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой коллекции в ходе
//        перебора коллекции и при получении элементов из коллекции без дополнительных
//        манипуляций мы гарантированно можем вызывать методы класса Dog ( bark() ) и методы
//        всех его предков - то есть методы классов Object и Pet ( eat() ).
//        Методы потомков Dog вызывать не можем.
//         */
//
//        List<SpecialDog> specialDogs = new ArrayList<>();
//        /*
//        Здесь <SpecialDog> говорит о том, что в этой коллекции могут находиться элементы по
//        своей иерархии не выше класса SpecialDog. Кроме того, У КАЖДОГО ЭЛЕМЕНТА этой
//        коллекции в ходе перебора коллекции и при получении элементов из коллекции без
//        дополнительных манипуляций мы гарантированно можем вызывать методы класса SpecialDog
//        ( search() ) иметоды всех его предков - то есть методы классов Object, Pet ( eat() )
//        и Dog ( bark() ). Методы потомков SpecialDog вызывать не можем.
//         */
//
//        /*
//        Получается, что параметр, указанный в треугольных скобках <Параметр>, диктует нам
//        следующие условия:
//        1. Допустимые классы в этой коллекции ограничивает сверху.
//        2. Допустимые методы в этой коллекции ограничивает снизу.
//        Например List<Dog> dogs = new ArrayList<>():
//        Максимальный допустимый класс - Dog, это и есть верхнее ограничение на класс.
//        Положить в коллекцию объект класса, находящегося по иерархии выше чем Dog, например
//        Pet, нельзя, но объект самого класса Dog и объекты классов ниже по иерархии можно.
//        С методами - наоборот. Параметр разрешает применять к каждому объекту коллекции
//        методы класса Dog и классов, находящихся выше по иерархии. И запрещает использовать
//        методы классов, находящихся ниже по иерархии, чем класс Dog.
//
//        Подытожим.
//        У List<Dog> dogs = new ArrayList<>():
//        Объекты каких классов можно класть: Dog и ниже (new Dog(); new SpecialDog()).
//        Методы каких классов можно использовать: Dog и выше (Dog; Pet; Object).
//
//         */
//
//        /*-----------------------------------------------------------------------------------*/
//
//        // Давай проверим на примере коллекции List<Object> objects = new ArrayList<>():
//
//        objects.add(0, new Object());
//        /*
//        Без проблем добавили в коллекцию в ячейку с индексом 0 (по сути в первую
//        ячейку) новый объект типа Object.
//         */
//        objects.add(1, new Pet());
//        /*
//        Без проблем добавили в коллекцию в ячейку с индексом 1 (по сути во вторую
//        ячейку) новый объект типа Pet. Почему без проблем? Потому что JAVA точно знает,
//        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр Pet),
//        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена,
//        что у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
//        При этом, она сразу как бы "закрывает доступ" к единственному собственному методу
//        экземпляра Pet - eat(), делая его "невидимым". Теперь этот экземпляр Pet как будто
//        обычный экземпляр класса Object (якобы урезанная версия).
//         */
//        objects.add(2, new Dog());
//        /*
//        Без проблем добавили в коллекцию в ячейку с индексом 2 (по сути в третью
//        ячейку) новый объект типа Dog. Почему без проблем? Потому что JAVA точно знает,
//        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр Dog),
//        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена, что
//        у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
//        При этом, она сразу как бы "закрывает доступ" ко всем остальным методам экземпляра
//        Dog ( собственному методу bark() и унаследованному от Pet методу eat() ), делая их
//        "невидимыми". Теперь этот экземпляр Dog как будто обычный экземпляр класса Object
//        (якобы урезанная версия).
//         */
//        objects.add(3, new SpecialDog());
//        /*
//        Без проблем добавили в коллекцию в ячейку с индексом 3 (по сути в четвертую
//        ячейку) новый объект типа SpecialDog. Почему без проблем? Потому что JAVA точно знает,
//        что принимая в эту коллекцию (List<Object>) потомка класса Object (экземпляр SpecialDog),
//        она его преобразует в объект класса Object, как бы "запаковывает" его, и уверена, что
//        у него точно есть методы класса Object, и она сможет их вызвать у этого объекта.
//        При этом, она сразу как бы "закрывает доступ" ко всем остальным методам экземпляра
//        SpecialDog ( собственному методу search(), унаследованному от Dog методу bark() и
//        унаследованному от Pet методу eat() ), делая их "невидимыми". Теперь этот экземпляр
//        SpecialDog как будто обычный экземпляр класса Object (якобы урезанная версия).
//         */
//
//
//        /*
//        Мы помним ограничения этой конкретной коллекции: у этих объектов в коллекции мы
//        можем вызвать только методы класса Object, их личные методы и унаследованные методы
//        у классов, находящихся вплоть до Object, мы вызвать НЕ МОЖЕМ:
//         */
//
//        // 1.Перебираем коллекцию, в ходе чего у каждого элемента вызываем метод класса Object:
//        for (Object o : objects) {
//            System.out.println(o.hashCode());
//        } // Без проблем итерируем и вызываем метод класса
//        // Object у каждого элемента коллекции. У меня в консоль вывелось следующее:
//        // 1639705018
//        // 1627674070
//        // 1360875712
//        // 1625635731
//
//
//        // 2.Теперь получим элементы из коллекции методом get():
//
//        Object object0 = objects.get(0); // достали первый объект (который имел тип Object)
//        // и записали в переменную object0. Вызываем у объекта любой метод класса Object,
//        // например toString():
//        System.out.println(object0.toString()); // без проблем вызываются методы класса Object
//
//        Object object1 = objects.get(1);// достали первый объект (который имел тип Pet)
//        // и записали в переменную object1. Вызываем у объекта любой метод класса Object,
//        // например hashCode():
//        System.out.println(object1.hashCode()); // без проблем вызываются методы класса Object.
//
//        // Это же был у нас объект типа Pet? Попытаемся достать этот объект и записать его в
//        // переменную типа Pet:
////        Pet pet1 = objects.get(1); // компилятор ругается^ потому что мы пытаемся в переменную
//        // типа Pet записать объект типа Object, поэтому надо явно указать, что мы уверены, что
//        // это объект типа Pet и сделать приведение типов (cast):
//        Pet pet = (Pet) objects.get(1); // Всё отлично. Мы как бы "распаковали" из объекта
//        // класса Object наш объект класса Pet. И теперь можем вызывать у него не только методы
//        // класса Object, но и методы класса Pet:
//        System.out.println(pet.hashCode()); // Ок!
//        pet.eat(); // "Pet is eating..." Всё отлично. Его собственный метод вызывается без проблем.
//
//
//        // Аналогичная ситуация с объектами типа Dog и SpecialDog:
//        Object object2 = objects.get(2); // Можем достать объект типа Dog "нераспакованным" и
//        // иметь возможность вызывать только методы класса Object. Либо:
//        Dog dog = (Dog) objects.get(2); // Можем достать объект типа Dog "распакованным" и
//        // иметь возможность вызывать у него не только методы класса Object, но и собственный
//        // метод класса Dog - bark(), и унаследованный от Pet метод eat():
//        dog.hashCode(); // Ок!
//        dog.eat(); // "Pet is eating..."
//        dog.bark(); // "Dog is barking..."
//
//
//        Object object3 = objects.get(3); // Можем достать объект типа SpecialDog
//        // "нераспакованным" и иметь возможность вызывать только методы класса Object. Либо:
//        SpecialDog specialDog = (SpecialDog) objects.get(3); // Можем достать объект типа Dog
//        // "распакованным" и иметь возможность вызывать у него не только методы класса Object,
//        // но и собственный метод класса SpecialDog - search(), унаследованный от Dog метод
//        // bark(), и унаследованный от Pet метод eat():
//        specialDog.hashCode(); // Ок!
//        specialDog.eat(); // "Pet is eating..."
//        specialDog.bark(); // "Dog is barking..."
//        specialDog.search(); // "SpecialDog is searching..."
//    }
//}
